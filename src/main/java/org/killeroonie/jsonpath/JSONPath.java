package org.killeroonie.jsonpath;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import org.killeroonie.jsonpath.JSONPathEnvironment;
/**
 * A compiled JSONPath ready to be applied to a JSON string or Java object.
 */
public class JSONPath {
    /**
     * The JSONPathEnvironment this path is bound to.
     */
    public final JSONPathEnvironment env;
    /**
     * The JSONPathSelector instances that make up this path.
     */
    public final List<JSONPathSelector> selectors;
    private final boolean fakeRoot;

    /**
     * A compiled JSONPath ready to be applied to a JSON string or Java object.
     *
     * @param env       The JSONPathEnvironment this path is bound to.
     * @param selectors An iterable of JSONPathSelector objects, as generated by a Parser.
     * @param fakeRoot  Indicates if target JSON values should be wrapped in a single-element array to make
     *                  the target root value selectable.
     */
    public JSONPath(JSONPathEnvironment env, Iterable<JSONPathSelector> selectors, boolean fakeRoot) {
        this.env = env;
        this.selectors = new ArrayList<>();
        for (JSONPathSelector selector : selectors) {
            this.selectors.add(selector);
        }
        this.fakeRoot = fakeRoot;
    }

    public JSONPath(JSONPathEnvironment env, Iterable<JSONPathSelector> selectors) {
        this(env, selectors, false);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder(env.rootToken);
        for (JSONPathSelector selector : selectors) {
            sb.append(selector.toString());
        }
        return sb.toString();
    }

    @Override
    public boolean equals(Object other) {
        if (!(other instanceof JSONPath)) {
            return false;
        }
        JSONPath otherPath = (JSONPath) other;
        return selectors.equals(otherPath.selectors);
    }

    @Override
    public int hashCode() {
        return selectors.hashCode();
    }

    /**
     * Find all objects in data matching the given JSONPath path.
     * <p>
     * If data is a string or a file-like object, it will be loaded
     * using JSON parsing and the default JSONDecoder.
     *
     * @param data          A JSON document or Java object implementing the List or Map interfaces.
     * @param filterContext Arbitrary data made available to filters using the filter context selector.
     * @return A list of matched objects. If there are no matches, the list will be empty.
     * @throws RuntimeException If the path is invalid or if a filter expression attempts to use types
     *                          in an incompatible way.
     */
    public List<Object> findall(Object data, FilterContextVars filterContext) {
        return StreamSupport.stream(finditer(data, filterContext).spliterator(), false)
                .map(match -> match.obj)
                .collect(Collectors.toList());
    }

    public List<Object> findall(Object data) {
        return findall(data, null);
    }

    /**
     * Generate JSONPathMatch objects for each match.
     * <p>
     * If data is a string or a file-like object, it will be loaded
     * using JSON parsing and the default JSONDecoder.
     *
     * @param data          A JSON document or Java object implementing the List or Map interfaces.
     * @param filterContext Arbitrary data made available to filters using the filter context selector.
     * @return An iterator yielding JSONPathMatch objects for each match.
     * @throws RuntimeException If the path is invalid or if a filter expression attempts to use types
     *                          in an incompatible way.
     */
    public Iterable<JSONPathMatch> finditer(Object data, FilterContextVars filterContext) {
        Object _data = JsonLoader.load(data);
        Iterable<JSONPathMatch> matches = Arrays.asList(
                new JSONPathMatch(
                        filterContext != null ? filterContext : new FilterContextVars(),
                        fakeRoot ? Arrays.asList(_data) : _data,
                        null,
                        env.rootToken,
                        new ArrayList<>(),
                        _data
                )
        );

        for (JSONPathSelector selector : selectors) {
            matches = selector.resolve(matches);
        }

        return matches;
    }

    public Iterable<JSONPathMatch> finditer(Object data) {
        return finditer(data, null);
    }

    /**
     * An async version of findall().
     */
    public CompletableFuture<List<Object>> findallAsync(Object data, FilterContextVars filterContext) {
        return finditerAsync(data, filterContext)
                .thenApply(stream -> stream.map(match -> match.obj).collect(Collectors.toList()));
    }

    public CompletableFuture<List<Object>> findallAsync(Object data) {
        return findallAsync(data, null);
    }

    /**
     * An async version of finditer().
     */
    public CompletableFuture<Stream<JSONPathMatch>> finditerAsync(Object data, FilterContextVars filterContext) {
        Object _data = JsonLoader.load(data);

        CompletableFuture<Stream<JSONPathMatch>> matches = CompletableFuture.completedFuture(
                Stream.of(new JSONPathMatch(
                        filterContext != null ? filterContext : new FilterContextVars(),
                        fakeRoot ? Arrays.asList(_data) : _data,
                        null,
                        env.rootToken,
                        new ArrayList<>(),
                        _data
                ))
        );

        for (JSONPathSelector selector : selectors) {
            matches = selector.resolveAsync(matches);
        }

        return matches;
    }

    public CompletableFuture<Stream<JSONPathMatch>> finditerAsync(Object data) {
        return finditerAsync(data, null);
    }

    /**
     * Return a JSONPathMatch instance for the first object found in data.
     * <p>
     * null is returned if there are no matches.
     *
     * @param data          A JSON document or Java object implementing the List or Map interfaces.
     * @param filterContext Arbitrary data made available to filters using the filter context selector.
     * @return A JSONPathMatch object for the first match, or null if there were no matches.
     * @throws RuntimeException If the path is invalid or if a filter expression attempts to use types
     *                          in an incompatible way.
     */
    public JSONPathMatch match(Object data, FilterContextVars filterContext) {
        Iterator<JSONPathMatch> iterator = finditer(data, filterContext).iterator();
        return iterator.hasNext() ? iterator.next() : null;
    }

    public JSONPathMatch match(Object data) {
        return match(data, null);
    }

    /**
     * Return a Query iterator over matches found by applying this path to data.
     *
     * @param data          A JSON document or Java object implementing the List or Map interfaces.
     * @param filterContext Arbitrary data made available to filters using the filter context selector.
     * @return A query iterator.
     * @throws RuntimeException If the path is invalid or if a filter expression attempts to use types
     *                          in an incompatible way.
     */
    public Query query(Object data, FilterContextVars filterContext) {
        return new Query(finditer(data, filterContext), env);
    }

    public Query query(Object data) {
        return query(data, null);
    }

    /**
     * Return true if this path has no selectors.
     */
    public boolean empty() {
        return selectors.isEmpty();
    }

    /**
     * Return true if this JSONPath query is a singular query.
     */
    public boolean singularQuery() {
        for (JSONPathSelector selector : selectors) {
            if (selector instanceof PropertySelector || selector instanceof IndexSelector) {
                continue;
            }
            if (selector instanceof ListSelector) {
                ListSelector listSelector = (ListSelector) selector;
                if (listSelector.items.size() == 1 &&
                        (listSelector.items.get(0) instanceof PropertySelector ||
                                listSelector.items.get(0) instanceof IndexSelector)) {
                    continue;
                }
            }
            return false;
        }
        return true;
    }
}
